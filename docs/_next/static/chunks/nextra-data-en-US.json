{"/docs":{"title":"介绍","data":{"nestjs-介绍#NestJS 介绍":"NestJS 是一个开源的 Node.js 框架，用于构建高效、可扩展的服务器端应用程序。它使用 TypeScript 编写，并结合了 OOP（面向对象编程）、FP（函数式编程）和 FRP（函数响应式编程）的元素，以提供一种现代且结构化的方式来构建企业级应用程序。","核心特性#核心特性":"现代JavaScript：NestJS 完全基于 TypeScript，利用其类型系统和面向对象的特性来构建稳健的应用程序。\n模块化：NestJS 采用模块化的设计，使得应用程序可以被分解成更小、更易管理的部分。\n依赖注入：框架提供了一个强大的依赖注入系统，类似于 Spring，可以轻松地管理服务的依赖关系。\n端点路由：NestJS 提供了一个声明式的路由系统，使得定义端点和控制器变得简单直观。\n中间件和管道：框架支持中间件和管道，允许开发者在处理 HTTP 请求之前或之后执行逻辑。\n服务和守卫：NestJS 允许创建服务和守卫，这些可以在应用程序中被复用，并提供了请求处理的额外层。\n可测试性：由于其模块化和依赖注入的特性，NestJS 应用程序易于编写单元测试和集成测试。\n微服务支持：NestJS 支持构建微服务架构，并且与消息传递系统（如 MQTT 或 WebSockets）集成良好。","发展历程#发展历程":"NestJS 的发展始于对 Node.js 社区中缺乏一个结构化框架的需求。2016年，Kamil Mysliwiec 受到了 Angular 的启发，\n它将 Angular 的许多概念，如依赖注入、模块化和服务，带入了 Node.js 后端开发并创建了 NestJS 框架。目前 NestJS 已经被广泛认可，并成为 Node.js 开发者构建新应用程序的首选框架之一，特别是在需要构建大型、可扩展和维护性强的应用程序时。","代码示例#代码示例":"一个最简单的NestJS项目文件夹结构如下：\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nasync function main() {\n    const app = await NestFactory.create(AppModule);\n    await app.listen(8080);\n}\nmain();\nimport { Module } from '@nestjs/common';\nimport { HelloController } from './hello.controller';\n@Module({\n    controllers: [HelloController],\n})\nexport class AppModule {}\nimport { Controller, Get } from '@nestjs/common';\n@Controller()\nexport class HelloController {\n    @Get()\n    getHello(): string {\n        return 'Hello World';\n    }\n}","springboot-介绍#SpringBoot 介绍":"Spring Boot 是一个开源的 Java 基础框架，由 Pivotal 团队提供，用于创建独立、生产级别的基于 Spring 的应用程序。\n它旨在简化 Spring 应用的初始搭建以及开发过程，通过自动配置和“约定大于配置”的原则，使开发者能够快速搭建独立、生产级别的应用程序。","核心特性-1#核心特性":"简化配置：Spring Boot 采用约定优于配置的方式，通过自动化配置和默认设置来简化开发者的配置工作，减少了繁琐的配置代码。\n内嵌Web容器：Spring Boot 内置了多种常用的 Web 容器，如 Tomcat、Jetty、Undertow 等，使得构建独立的 Web 应用程序变得更加简单。\n自动化依赖管理：通过提供一系列的“starter”依赖，Spring Boot 自动管理了应用程序的依赖关系，简化了依赖管理的工作。\n开发者工具：Spring Boot 提供了丰富的开发者工具，如热部署、自动重启、自动配置报告等，提高了开发效率。\n外部化配置：支持使用外部配置文件来配置应用程序的属性，如数据库连接、日志配置等，使得应用程序的配置更加灵活和可管理。\n高度可扩展：基于 Spring 框架，Spring Boot 支持丰富的扩展点和插件，使得应用程序的功能可以方便地进行扩展和定制。","发展历程-1#发展历程":"Spring Boot 的发展可以追溯到 Spring 框架的演变。Spring 框架自 2003 年由 Rod Johnson 创建，并在 2004 年开源。\n随着时间的推移，Spring 框架逐渐成为 Java 企业级开发中不可或缺的一部分。2014年，基于 Spring 4.0 设计的 Spring Boot 1.0 版本发布，它不仅继承了 Spring 框架原有的优秀特性，而且还通过简化配置来进一步简化了 Spring 应用的整个搭建和开发过程。\nSpring Boot 通过集成大量的框架使得依赖包的版本冲突以及引用的不稳定性等问题得到了很好的解决。随着 Spring Boot 3.0 版本的推出，Spring Boot 继续在简化开发和提高生产效率方面取得了显著的进步。\n目前 Spring Boot 已经被广泛认可，并成为 Java 开发者构建新应用程序的首选框架之一。","代码示例-1#代码示例":"一个最简单的SpringBoot项目文件夹结构如下 :\npackage com.example;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n@SpringBootApplication\npublic class HelloApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApplication.class, args);\n    }\n}\npackage com.example;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n@RestController\npublic class HelloController {\n    @GetMapping(\"/\")\n    public String hello() {\n        return \"Hello World\";\n    }\n}\nserver:\n  port: 8080"}},"/docs/server":{"title":"Web服务器","data":{"":"本章将介绍驱动NestJS和SpringBoot上层框架的底层Web服务器。","express#Express":"NestJS在底层使用了Express作为其Web服务器之一。这意味着，当你使用NestJS构建应用程序时，你实际上是在使用Express的所有功能，但以一种更结构化和模块化的方式。NestJS通过其装饰器和模块系统，为Express提供了额外的抽象层，使得代码更加整洁和易于维护。","使用-express#使用 Express":"安装 Express\npnpm add express\n由于 Express 是使用 JavaScript 编写的，因此需要额外安装 Express 的 TypeScript 类型声明\npnpm add -D @types/express # -D 选项表示安装依赖项到开发环境，生产环境构建的时候不需要包含该依赖项\n创建 Express 应用程序\nimport Express from 'express';\nconst app = Express();\napp.get('/', (req, res) => {\n    res.send('Hello World');\n});\napp.listen(8080, () => {\n    console.log('Server is running on http://localhost:8080');\n});\n启动应用程序\n配置开发环境启动命令\n{\n\t\"name\": \"@ell/api\",\n\t\"version\": \"1.0.0\",\n\t\"scripts\": {\n\t\t\"build\": \"tsc ./src/index.ts\",\n\t\t\"start\": \"node ./dist/index.js\",\n\t\t\"dev\": \"tsx watch ./src/index.ts\"\n\t},\n\t\"dependencies\": {\n\t\t\"express\": \"^4.21.1\"\n\t},\n\t\"devDependencies\": {\n\t\t\"@types/express\": \"^5.0.0\",\n\t\t\"tsx\": \"^4.19.2\",\n\t\t\"typescript\": \"^5.7.2\"\n\t}\n}\n启动服务器\n(base) \u001b[0;32m ➜ \u001b[0m \u001b[38;5;31mapi\u001b[0m pnpm dev\n> @ell/api@1.0.0 dev /Users/roylin/Desktop/ell/pnpm-mono/apps/api\n> tsx ./src/index.ts\nServer is running on \u001b[0;32mhttp://localhost:8080\u001b[0m\n浏览器访问: http://localhost:8080 可以看到输出 Hello World\n使用中间件\n编写一个简单的日志中间件。这个中间件将记录每个请求的方法、路径和响应时间。\nimport Express from 'express';\nconst logger = (req: Express.Request, res: Express.Response, next: Express.NextFunction) => {\n    const start = Date.now(); // 请求开始时间 \n    res.on('finish', () => { // 当响应结束时触发\n        const duration = Date.now() - start; // 计算响应时间\n        console.log(`${req.method} ${req.url} ${res.statusCode} ${duration}ms`); // 记录日志\n    });\n    next(); // 继续处理请求\n}\nconst app = Express();\napp.use(logger);\napp.get('/', (req, res) => {\n    res.send('Hello World');\n});\napp.listen(8080, () => {\n    console.log('Server is running on http://localhost:8080');\n});\n再次访问 http://localhost:8080 可以看到浏览器输出 Hello World 的同时，终端输出了日志。\nGET / 200 1ms","tomcat#Tomcat":"Spring Boot 在底层使用了 Tomcat 作为其内嵌 Web 服务器之一。这意味着，当你使用 Spring Boot 构建应用程序时，你实际上是在以一种更简洁和自动化的方式使用 Tomcat 的所有功能。Spring Boot 通过其自动配置和 starters，为 Tomcat 提供了额外的抽象层，使得代码更加整洁和易于维护。","使用-tomcat#使用 Tomcat":"安装 Tomcat\n<project>\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>com.ell</groupId>\n        <artifactId>maven-monorepo</artifactId>\n        <version>1.0.0-SNAPSHOT</version>\n        <relativePath>../pom.xml</relativePath>\n    </parent>\n    <artifactId>api</artifactId>\n    <dependencies>\n        <dependency>\n            <groupId>org.apache.tomcat.embed</groupId>\n            <artifactId>tomcat-embed-core</artifactId>\n            <version>8.5.100</version>\n        </dependency>\n        <dependency>\n            <groupId>com.ell</groupId>\n            <artifactId>packagea</artifactId>\n            <version>1.0.0-SNAPSHOT</version>\n        </dependency>\n        <dependency>\n            <groupId>com.ell</groupId>\n            <artifactId>packageb</artifactId>\n            <version>1.0.0-SNAPSHOT</version>\n        </dependency>\n    </dependencies>\n    <build>\n        <pluginManagement>\n            <plugins>          \n                <plugin>\n                    <groupId>org.codehaus.mojo</groupId>\n                    <artifactId>exec-maven-plugin</artifactId>\n                    <version>3.0.0</version>\n                    <configuration>\n                        <mainClass>com.ell.api.Api</mainClass>\n                    </configuration>\n                </plugin>      \n            </plugins>\n        </pluginManagement>\n    </build>\n</project>\n创建 Tomcat 应用程序\npackage com.ell.api;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.startup.Tomcat;\npublic class Api {\n    public static void main(String[] args) throws LifecycleException {\n        Tomcat tomcat = new Tomcat();\n        tomcat.setPort(8080);\n        tomcat.setBaseDir(\"temp\");\n        tomcat.addContext(\"\", new File(\".\").getAbsolutePath());\n        tomcat.addServlet(\"\", \"hello\", new HttpServlet() {\n            @Override\n            protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                    throws ServletException, IOException {\n                PrintWriter writer = resp.getWriter();\n                writer.write(\"Hello World\");\n            }\n        }).addMapping(\"/\");\n        tomcat.start();\n        System.out.println(\"Server is running on http://localhost:8080\");\n        tomcat.getServer().await();\n    }\n}\n启动应用程序\n(base) \u001b[0;32m ➜ \u001b[0m \u001b[38;5;31mmaven-mono\u001b[0m mvn -f api/pom.xml exec:java\n[\u001b[38;5;31mINFO\u001b[0m] Scanning for projects...\n[\u001b[38;5;31mINFO\u001b[0m]\n[\u001b[38;5;31mINFO\u001b[0m] ----------------------------< \u001b[38;5;31mcom.ell:api\u001b[0m >-----------------------------\n[\u001b[38;5;31mINFO\u001b[0m] Building api 1.0.0-SNAPSHOT\n[\u001b[38;5;31mINFO\u001b[0m]   from pom.xml\n[\u001b[38;5;31mINFO\u001b[0m] --------------------------------[ jar ]---------------------------------\n[\u001b[38;5;31mINFO\u001b[0m]\n[\u001b[38;5;31mINFO\u001b[0m] --- exec:3.0.0:java (default-cli) @ api ---\n11月 29, 2024 3:04:20 下午 org.apache.coyote.AbstractProtocol init\n信息: Initializing ProtocolHandler [\"http-nio-8080\"]\n11月 29, 2024 3:04:20 下午 org.apache.catalina.core.StandardService startInternal\n信息: Starting service [Tomcat]\n11月 29, 2024 3:04:20 下午 org.apache.catalina.core.StandardEngine startInternal\n信息: Starting Servlet engine: [Apache Tomcat/8.5.100]\n11月 29, 2024 3:04:20 下午 org.apache.coyote.AbstractProtocol start\n信息: Starting ProtocolHandler [\"http-nio-8080\"]\nServer is running on \u001b[0;32mhttp://localhost:8080\u001b[0m\n浏览器访问: http://localhost:8080 可以看到输出 Hello World\n使用过滤器\n通过创建过滤器可以实现和 Express 中间件类似的功能\npackage com.ell.api;\nimport java.io.IOException;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\npublic class LoggerFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        // 转换为HTTP请求和响应以访问特定的方法和属性\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n        // 请求开始时间\n        long start = System.currentTimeMillis();\n        // 继续执行过滤器链\n        chain.doFilter(request, response);\n        // 计算响应时间\n        long duration = System.currentTimeMillis() - start;\n        // 获取响应状态码\n        int statusCode = httpResponse.getStatus();\n        // 记录日志\n        String method = httpRequest.getMethod();\n        String url = httpRequest.getRequestURI();\n        log(method, url, statusCode, duration);\n    }\n    @Override\n    public void destroy() {\n    }\n    private void log(String method, String url, int statusCode, long duration) {\n        // 构建日志信息\n        String logMessage = String.format(\"%s %s %d %dms\", method, url, statusCode, duration);\n        System.out.println(logMessage); // 输出到控制台，也可以改为记录到文件或其他日志系统\n    }\n}\n要让 Tomcat 能正确加载过滤器，需要为上下文对象设置正确的类加载器\npackage com.ell.api;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.catalina.Context;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.startup.Tomcat;\nimport org.apache.tomcat.util.descriptor.web.FilterDef;\nimport org.apache.tomcat.util.descriptor.web.FilterMap;\npublic class Api {\n    public static void main(String[] args) throws LifecycleException {\n        Tomcat tomcat = new Tomcat();\n        tomcat.setPort(8080);\n        tomcat.setBaseDir(\"temp\");\n        Context context = tomcat.addContext(\"\", new File(\".\").getAbsolutePath());\n        ClassLoader classLoader = tomcat.getClass().getClassLoader();\n        context.setParentClassLoader(classLoader);\n        tomcat.addServlet(\"\", \"hello\", new HttpServlet() {\n            @Override\n            protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                    throws ServletException, IOException {\n                PrintWriter writer = resp.getWriter();\n                writer.write(\"Hello World\");\n            }\n        }).addMapping(\"/\");\n        FilterDef filterDef = new FilterDef();\n        filterDef.setFilterClass(LoggerFilter.class.getName());\n        filterDef.setFilterName(\"loggerFilter\");\n        context.addFilterDef(filterDef);\n        FilterMap filterMap = new FilterMap();\n        filterMap.setFilterName(\"loggerFilter\");\n        filterMap.addURLPattern(\"/*\");\n        context.addFilterMap(filterMap);\n        tomcat.start();\n        System.out.println(\"Server is running on http://localhost:8080\");\n        tomcat.getServer().await();\n    }\n}\n再次访问 http://localhost:8080 可以看到浏览器输出 Hello World 的同时，终端输出了日志。\nGET / 200 1ms"}},"/":{"title":"介绍","data":{"":"SVN (SpringBoot VS NestJS) 作为一个资源平台，我们的目标是为开发者提供一个深入、全面的比较和学习环境。我们相信，通过对比 Spring Boot 和 NestJS 的核心特性、设计理念和适用场景，开发者可以更好地选择适合自己项目需求的技术栈。","适用人群#适用人群":"想要学习SprintBoot的Node.js开发者和想要学习NestJS的Java开发者，都可以在这里找到有关Spring Boot和NestJS的比较，以及学习路径的建议。","为什么要学习这两个框架呢#为什么要学习这两个框架呢？":"在当今这个技术多元化的时代，作为开发者，我们面临着不断涌现的新工具和框架。Spring Boot 和 NestJS 作为两个现代流行的后端框架，各自在不同的技术栈和应用场景中展现出独特的优势。那么，为什么我们要同时学习这两个框架呢？首先，技术多样性是现代软件开发的核心。掌握 Spring Boot 可以帮助我们深入理解 Java 生态系统的强大功能和企业级应用的开发模式。它在微服务架构、数据访问、事务管理等方面的成熟解决方案，使其成为构建稳定、可靠后端服务的首选， 并且大部分信创目和软件都优先选择支持 Java 语言。而 NestJS 则为我们打开了 JavaScript/TypeScript 生态的大门，让我们能够利用 Node.js 的非阻塞 I/O 和事件驱动特性，构建高性能和高并发的应用程序。NestJS 的现代性和对最新 JavaScript 特性的支持，使其在构建云原生应用和微服务方面具有独特的优势，在人工智能等新兴领域中 TypeScript 也成为了主流开发语言。其次，跨语言学习能够拓宽我们的视野。通过学习 Spring Boot，JavaScript/TypeScript 开发者可以获得对 Java 强类型语言和面向对象编程的深刻理解，这对于提升代码质量和系统设计能力至关重要。反过来，Java 开发者通过学习 NestJS，可以更好地理解函数式编程和响应式编程的概念，这些在现代 Web 开发中越来越重要。综上所述，同时学习 Spring Boot 和 NestJS 不仅能够帮助我们更好地适应技术发展的趋势，还能够让我们在不同的技术领域中找到交叉点，从而成为更全面、更有竞争力的开发者。让我们拥抱变化，不断学习，共同探索技术的未来。","网站特色#网站特色":"框架对比：深入探讨Spring Boot和NestJS的设计哲学、架构模式和核心功能。\n实战案例：通过实际项目案例，展示如何在不同场景下使用这两个框架。\n路径规划：为不同背景的开发者提供定制化的学习路径。\n社区互动：提供一个平台，让开发者可以交流心得、讨论问题。\n资源下载：提供教程、代码示例和文档的下载链接。"}},"/docs/setup":{"title":"环境搭建","data":{"nestjs环境搭建#NestJS环境搭建":"","安装-nodejs#安装 Node.js":"安装 nvm (Node 版本管理器)\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash\n加载 nvm\n export NVM_DIR=\"$([ -z \"${XDG_CONFIG_HOME-}\" ] && printf %s \"${HOME}/.nvm\" || printf %s \"${XDG_CONFIG_HOME}/nvm\")\"\n [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"\n安装 Node.js（可能需要重启终端）\nnvm install 22\n验证环境中是否存在正确的 Node.js 版本\nnode -v\n验证环境中是否存在正确的 npm（默认的包管理器） 版本\nnpm -v\n安装 pnpm（更先进的包管理器）\nnpm install -g pnpm","创建-nestjs-项目#创建 NestJS 项目":"创建项目文件夹：\nmkdir nestjs-project && cd nestjs-project\n# 或\ngit clone https://github.com/nestjs/typescript-starter.git .\n安装NestJS CLI：\npnpm add -g @nestjs/cli\n# 或\npnpm install -g @nestjs/cli\n创建项目(使用 NestJS CLI 创建项目)：\nnest new .\n安装依赖(根据 package.json 文件中的定义下载对应的依赖项)：\npnpm i \n# 或\npnpm install\n开发模式运行使用 pnpm 运行定义在 package.json 中 scripts 字段下的命令:\npnpm start # 等效于 pnpm run start\n# 或\npnpm start:dev # 支持热重载\n编译项目\n将 src 目录中的 TypeScript 源文件编译并输出到 dist 目录:\npnpm build\n生产模式运行\n使用 node 命令执行编译后的 js 文件:\npnpm start:prod # 等效于 node dist/main.js","springboot环境搭建#SpringBoot环境搭建":"","安装-java-和-maven#安装 Java 和 Maven":"安装 SDKMANSDKMAN 是一个软件开发工具包管理器，用于管理不同版本的 Java SDK 和 Maven。在终端中运行以下命令来安装 SDKMAN：\ncurl -s \"https://get.sdkman.io\" | bash\n安装完成后，关闭并重新打开终端，或运行以下命令以使 SDKMAN 立即生效：\nsource \"$HOME/.sdkman/bin/sdkman-init.sh\"\n使用 SDKMAN 安装 Java 17(SpringBoot 3.0项目，官方推荐使用 Java 17)：安装 Java 17 的最新版本：\nsdk install java 17.0.12-jbr\n验证 Java 安装：验证 Java 是否正确安装：\njava -version\n使用 SDKMAN 安装 Maven 3.9.9安装特定版本的 Maven：\nsdk install maven 3.9.9\n验证 Maven 安装验证 Maven 是否正确安装：\nmvn -version","创建-springboot-项目#创建 SpringBoot 项目":"使用 Spring Initializr 创建项目访问 Spring Initializr 网站，选择项目元数据（如 Group, Artifact），依赖项（如 Spring Web），以及配置（如 Java 17, Maven）。完成后，下载生成的项目压缩包，并解压到你的项目文件夹中。\n或者使用 Maven 命令行创建项目如果你更喜欢使用命令行，可以使用以下 Maven 命令来生成一个基本的 SpringBoot 项目：安装 maven springboot archetype\ngit clone git@github.com:elljs/maven-spring-boot-3-archetype.git \ncd maven-spring-boot-3-archetype\nmvn install\n使用 maven archetype 创建项目，需要将 groudId 替换为你的公司或组织的ID 以及将 artifactId 替换为你的项目名称\nmvn archetype:generate \\\n   -DgroupId=com.example \\\n   -DartifactId=springboot-project \\\n   -DarchetypeGroupId=com.ell.maven-archetypes \\\n   -DarchetypeArtifactId=spring-boot-3 \\\n   -DarchetypeVersion=1.0 \\\n   -DinteractiveMode=false\n然后，进入项目目录：\ncd springboot-project\n安装项目依赖使用 Maven 安装项目依赖：\nmvn install\n运行 SpringBoot 应用使用 Maven 运行 SpringBoot 应用：\nmvn spring-boot:run\n编译项目将 Java 源代码编译为字节码：\nmvn compile\n打包项目将编译后的字节码打包为一个可执行的 JAR 文件：\nmvn package\n生产模式运行使用 Java 命令执行打包后的 JAR 文件：\njava -jar target/springboot-project-1.0-SNAPSHOT.jar"}},"/docs/monorepo":{"title":"什么是 Monorepo？","data":{"":"Monorepo（单体仓库）是一种软件工程中的版本控制系统，它将多个项目或模块放在一个单一的仓库中管理，而不是分散在多个独立的仓库中。这种模式在现代软件开发中越来越受欢迎，因为它提供了几个显著的优势：\n简化的依赖管理：Monorepo 允许跨项目的依赖关系更容易管理，因为所有代码都位于同一仓库中。\n统一的构建和测试：Monorepo 使得整个代码库的构建和测试更加一致和集中。\n更好的代码共享：Monorepo 促进了代码和工具的共享，有助于减少重复代码。\n简化的代码审查：开发者可以在一个上下文中审查跨多个项目的代码变更，这有助于保持代码的一致性和质量。\n更高效的协作：团队成员可以更容易地协作和理解整个系统的代码结构。","使用-pnpm-创建-typescript-monorepo#使用 pnpm 创建 TypeScript Monorepo":"pnpm 支持 workspaces 功能，允许你在一个仓库中管理多个包。以下是如何使用 pnpm 创建和管理 Monorepo 的基本步骤：\n初始化 Monorepo创建一个新的目录，并初始化一个新的 pnpm 工作区：\nmkdir pnpm-mono\ncd pnpm-mono\npnpm init -y\n修改生成 package.json 中的 name 字段为 @ell/monorepo，@ell 部分是你的公司或组织名称\n{\n     \"name\": \"@ell/monorepo\",\n     \"version\": \"1.0.0\"\n }\n配置 workspace在 pnpm-mono 目录下定义工作区，并使用 tsup 作为 TypeScript 打包构建工具，使用 biome 作为代码格式化工具， 使用 tsx 作为 TypeScript 开发环境运行工具。\n{\n   \"name\": \"@ell/monorepo\",\n   \"version\": \"1.0.0\",\n   \"scripts\": {\n      \"preinstall\": \"npx only-allow pnpm\",\n      \"build\": \"pnpm --filter \\\"./packages/**\\\" run build\",\n      \"clean\": \"pnpm --filter=@elljs/* run clean\",\n      \"format\": \"pnpm biome format --write .\"\n   },\n   \"devDependencies\": {\n      \"@biomejs/biome\": \"^1.9.4\",\n      \"rimraf\": \"^6.0.1\",\n      \"tsup\": \"^8.3.5\",\n      \"tsx\": \"^4.19.2\"\n   }\n}\nimport { defineConfig } from 'tsup';\nexport default defineConfig([\n   {\n      entry: ['src/index.ts'],\n      outDir: 'dist',\n      target: 'node18',\n      platform: 'node',\n      format: ['cjs', 'esm'],\n      splitting: false,\n      sourcemap: true,\n      minify: true,\n      shims: true,\n      dts: true,\n   },\n]);\n{\n   \"$schema\": \"https://biomejs.dev/schemas/1.8.0/schema.json\",\n   \"organizeImports\": {\n      \"enabled\": true\n   },\n   \"vcs\": {\n      \"enabled\": true,\n      \"clientKind\": \"git\",\n      \"useIgnoreFile\": true\n   },\n   \"formatter\": {\n      \"enabled\": true,\n      \"formatWithErrors\": false,\n      \"ignore\": [],\n      \"indentStyle\": \"tab\",\n      \"indentWidth\": 2,\n      \"lineWidth\": 120\n   },\n   \"javascript\": {\n      \"formatter\": {\n         \"enabled\": true,\n         \"semicolons\": \"always\",\n         \"quoteStyle\": \"single\",\n         \"jsxQuoteStyle\": \"double\",\n         \"trailingCommas\": \"all\"\n      }\n   },\n   \"linter\": {\n      \"enabled\": true,\n      \"rules\": {\n         \"recommended\": true,\n         \"suspicious\": {\n            \"noExplicitAny\": \"off\"\n         }\n      }\n   }\n}\npackages:\n   - apps/*\n   - packages/*\nlink-workspace-packages = true\nprefer-workspace-packages = true\nrecursive-install = true\n.npmrc 中的配置:link-workspace-packages = true\n当设置为 true 时，这个选项会让 pnpm 自动将工作区中的包相互链接。也就是说，当一个包依赖于工作区中的另一个包时，pnpm 会创建一个符号链接（symlink），使得一个包可以直接引用另一个包的本地版本，而不是安装来自远程仓库的版本。这样可以加快开发速度，因为不需要重复下载和安装相同的代码。\nprefer-workspace-packages = true\n这个选项指示 pnpm 在安装依赖时，优先选择工作区中的包而不是远程仓库中的包。如果工作区中存在与远程仓库相同版本的包，pnpm 将使用工作区中的版本。这有助于确保开发和生产环境中使用的包版本一致，并且可以减少对外部仓库的依赖。\nrecursive-install = true\n当设置为 true 时，这个选项会让 pnpm 在安装依赖时递归地检查所有子工作区（sub-workspaces）的依赖。这意味着 pnpm 将不仅安装当前工作区的依赖，还会检查并安装所有子工作区的依赖。这有助于确保整个 monorepo 结构中的所有包都正确安装了它们的依赖。\n创建包在 packages 目录下创建不同的包：\ncd packages\nmkdir package-a package-b\npackage-a 和 package-b 包的 package.json 文件中的 name 字段分别为 @ell/package-a 和 @ell/package-bpackage-a 中的文件如下:\n{\n   \"name\": \"@ell/package-a\",\n   \"version\": \"1.0.0\",\n   \"type\": \"module\",\n   \"source\": \"./src/index.ts\",\n   \"types\": \"./dist/index.d.ts\",\n   \"sideEffects\": false,\n   \"exports\": {\n      \".\": {\n         \"import\": \"./dist/index.js\",\n         \"require\": \"./dist/index.cjs\",\n         \"default\": \"./dist/index.js\"\n      }\n   },\n   \"files\": [\"dist\"],\n   \"scripts\": {\n      \"build\": \"tsup --config ../../tsup.config.ts\",\n      \"clean\": \"rimraf dist && rimraf node_modules\"\n   },\n   \"devDependencies\": {\n      \"typescript\": \"^5.7.2\"\n   }\n}\nexport const fnA = () => console.log('package-a');\n{\n   \"extends\": [\"../../biome.json\"]\n}\n{\n   \"$schema\": \"https://json.schemastore.org/tsconfig\",\n   \"compilerOptions\": {\n      \"lib\": [\"esnext\", \"dom.iterable\", \"dom\"],\n      \"module\": \"esnext\",\n      \"moduleResolution\": \"bundler\",\n      \"moduleDetection\": \"force\",\n      \"noEmit\": true,\n      \"target\": \"es2020\",\n      \"outDir\": \"dist\",\n      \"allowImportingTsExtensions\": false,\n      \"allowJs\": true,\n      \"esModuleInterop\": true,\n      \"forceConsistentCasingInFileNames\": true,\n      \"incremental\": false,\n      \"isolatedModules\": true,\n      \"jsx\": \"preserve\",\n      \"noUncheckedIndexedAccess\": true,\n      \"resolveJsonModule\": true,\n      \"skipLibCheck\": true,\n      \"sourceMap\": true,\n      \"strict\": true,\n      \"useDefineForClassFields\": true,\n      \"verbatimModuleSyntax\": true,\n      \"baseUrl\": \".\",\n      \"paths\": {\n         \"@/*\": [\"./src/*\"]\n      }\n   },\n   \"include\": [\"src\"]\n}\npackage-b 中的文件如下:\n{\n   \"name\": \"@ell/package-b\",\n   \"version\": \"1.0.0\",\n   \"type\": \"module\",\n   \"source\": \"./src/index.ts\",\n   \"types\": \"./dist/index.d.ts\",\n   \"sideEffects\": false,\n   \"exports\": {\n      \".\": {\n         \"import\": \"./dist/index.js\",\n         \"require\": \"./dist/index.cjs\",\n         \"default\": \"./dist/index.js\"\n      }\n   },\n   \"files\": [\"dist\"],\n   \"scripts\": {\n      \"build\": \"tsup --config ../../tsup.config.ts\",\n      \"clean\": \"rimraf dist && rimraf node_modules\"\n   },\n   \"devDependencies\": {\n      \"typescript\": \"^5.7.2\"\n   }\n}\nexport const fnB = () => console.log('package-b');\n{\n   \"extends\": [\"../../biome.json\"]\n}\n{\n   \"$schema\": \"https://json.schemastore.org/tsconfig\",\n   \"compilerOptions\": {\n      \"lib\": [\"esnext\", \"dom.iterable\", \"dom\"],\n      \"module\": \"esnext\",\n      \"moduleResolution\": \"bundler\",\n      \"moduleDetection\": \"force\",\n      \"noEmit\": true,\n      \"target\": \"es2020\",\n      \"outDir\": \"dist\",\n      \"allowImportingTsExtensions\": false,\n      \"allowJs\": true,\n      \"esModuleInterop\": true,\n      \"forceConsistentCasingInFileNames\": true,\n      \"incremental\": false,\n      \"isolatedModules\": true,\n      \"jsx\": \"preserve\",\n      \"noUncheckedIndexedAccess\": true,\n      \"resolveJsonModule\": true,\n      \"skipLibCheck\": true,\n      \"sourceMap\": true,\n      \"strict\": true,\n      \"useDefineForClassFields\": true,\n      \"verbatimModuleSyntax\": true,\n      \"baseUrl\": \".\",\n      \"paths\": {\n         \"@/*\": [\"./src/*\"]\n      }\n   },\n   \"include\": [\"src\"]\n}\n在 package.json 文件中定义了与模块相关的配置，以下是每个字段的详细解释：\n\"type\": \"module\"\n这个字段指定包支持 ES 模块。它告诉 Node.js 和其他环境，所有的模块都是 ECMAScript 模块，这意味着你可以使用 import 和 export 语法。\n\"source\": \"./src/index.ts\"\n这个字段指定了 TypeScript 编译器的入口文件。它告诉编译器从 ./src/index.ts 文件开始编译。\n\"types\": \"./dist/index.d.ts\"\n这个字段指定了类型定义文件（.d.ts）的位置。当你安装这个包时，TypeScript 会查找这个文件来提供类型信息。这里指定的是 ./dist/index.d.ts。\n\"sideEffects\": false\n这个字段告诉打包工具（如 webpack、Rollup）这个包没有任何副作用（即不执行任何代码，除了导出）。这允许打包工具在优化时排除没有被引用的代码，从而减小最终包的大小。\n\"exports\": \n这个字段定义了模块的导出方式。它允许你指定不同条件下的入口点。\n\".\": 表示默认导出和命名导出的配置。\n\"import\": \"./dist/index.js\": 指定了当使用 import 语法时，应该加载的文件。\n\"require\": \"./dist/index.cjs\": 指定了当使用 require 语法时，应该加载的文件。这对于 CommonJS 模块兼容性很重要。\n\"default\": \"./dist/index.js\": 指定了默认导出的文件。\n\"files\": [\"dist\"]\n这个字段定义了当你的包被安装时，哪些文件应该被包含在内。这里指定的是只包含 dist 目录下的文件。\n这些字段共同定义了包的结构、兼容性和构建行为，使得包可以在不同的环境下正确地被构建和使用。通过精确控制导出和文件包含，你可以确保你的包在不同的模块系统中都能正常工作，并且提供良好的类型支持。\n创建应用在 apps 目录下创建应用：\ncd apps   \nmkdir api\n安装 package-a 和 package-b:\npnpm add @ell/package-a @ell/package-b\napi 中的文件如下:\n{\n   \"name\": \"@ell/api\",\n   \"version\": \"1.0.0\",\n   \"scripts\": {\n      \"build\": \"tsc ./src/index.ts\",\n      \"dev\": \"tsx ./src/index.ts\",\n      \"clean\": \"rimraf dist && rimraf node_modules\"\n   },\n   \"dependencies\": {\n      \"@ell/package-a\": \"workspace:^\",\n      \"@ell/package-b\": \"workspace:^\"\n   },\n   \"devDependencies\": {\n      \"typescript\": \"^5.7.2\"\n   }\n}\nimport { fnA } from '@ell/package-a';\nimport { fnB } from '@ell/package-b';\nfnA();\nfnB();\n{\n   \"extends\": [\"../../biome.json\"]\n}\n{\n   \"$schema\": \"https://json.schemastore.org/tsconfig\",\n   \"compilerOptions\": {\n      \"lib\": [\"esnext\", \"dom.iterable\", \"dom\"],\n      \"module\": \"esnext\",\n      \"moduleResolution\": \"bundler\",\n      \"moduleDetection\": \"force\",\n      \"noEmit\": true,\n      \"target\": \"es2020\",\n      \"outDir\": \"dist\",\n      \"allowImportingTsExtensions\": false,\n      \"allowJs\": true,\n      \"esModuleInterop\": true,\n      \"forceConsistentCasingInFileNames\": true,\n      \"incremental\": false,\n      \"isolatedModules\": true,\n      \"jsx\": \"preserve\",\n      \"noUncheckedIndexedAccess\": true,\n      \"resolveJsonModule\": true,\n      \"skipLibCheck\": true,\n      \"sourceMap\": true,\n      \"strict\": true,\n      \"useDefineForClassFields\": true,\n      \"verbatimModuleSyntax\": true,\n      \"baseUrl\": \".\",\n      \"paths\": {\n         \"@/*\": [\"./src/*\"]\n      }\n   },\n   \"include\": [\"src\"]\n}\n完整的目录结构如下：\n构建在根目录执行 pnpm install 命令， 然后执行 pnpm build 命令。\n(base) \u001b[0;32m ➜ \u001b[0m \u001b[38;5;31mpnpm-mono\u001b[0m pnpm build\n> @ell/monorepo@1.0.0 build /Users/roylin/Desktop/ell/pnpm-mono\n> pnpm --filter \"./packages/**\" run build\nScope: 2 of 4 workspace projects\npackages/package-a \u001b[38;5;31mbuild\u001b[0m$ tsup --config ../../tsup.config.ts\n[7 lines collapsed]\n\u001b[38;5;207m │ \u001b[0m ESM dist/index.js     86.00 B\n\u001b[38;5;207m │ \u001b[0m ESM dist/index.js.map 182.00 B\n\u001b[38;5;207m │ \u001b[0m ESM ⚡️ Build success in 10ms\n\u001b[38;5;207m │ \u001b[0m CJS dist/index.cjs     567.00 B\n\u001b[38;5;207m │ \u001b[0m CJS dist/index.cjs.map 285.00 B\n\u001b[38;5;207m │ \u001b[0m CJS ⚡️ Build success in 10ms\n\u001b[38;5;207m │ \u001b[0m DTS Build start\n\u001b[38;5;207m │ \u001b[0m DTS ⚡️ Build success in 335ms\n\u001b[38;5;207m │ \u001b[0m DTS dist/index.d.cts 48.00 B\n\u001b[38;5;207m │ \u001b[0m DTS dist/index.d.ts  48.00 B\n\u001b[38;5;207m └─ Done in 1.3s\u001b[0m\npackages/package-b \u001b[38;5;31mbuild\u001b[0m$ tsup --config ../../tsup.config.ts\n[7 lines collapsed]\n\u001b[38;5;207m │ \u001b[0m ESM dist/index.js     86.00 B\n\u001b[38;5;207m │ \u001b[0m ESM dist/index.js.map 182.00 B\n\u001b[38;5;207m │ \u001b[0m ESM ⚡️ Build success in 10ms\n\u001b[38;5;207m │ \u001b[0m CJS dist/index.cjs     567.00 B\n\u001b[38;5;207m │ \u001b[0m CJS dist/index.cjs.map 285.00 B\n\u001b[38;5;207m │ \u001b[0m CJS ⚡️ Build success in 10ms\n\u001b[38;5;207m │ \u001b[0m DTS Build start\n\u001b[38;5;207m │ \u001b[0m DTS ⚡️ Build success in 327ms\n\u001b[38;5;207m │ \u001b[0m DTS dist/index.d.cts 48.00 B\n\u001b[38;5;207m │ \u001b[0m DTS dist/index.d.ts  48.00 B\n\u001b[38;5;207m └─ Done in 1.3s\u001b[0m\n运行进入 apps/api 目录执行执行 pnpm dev 运行应用。\n(base) \u001b[0;32m ➜ \u001b[0m \u001b[38;5;31mapi\u001b[0m pnpm dev\n> @ell/api@1.0.0 dev /Users/roylin/Desktop/ell/pnpm-mono/apps/api\n> tsx ./src/index.ts\npackage-a\npackage-b\n源码地址：https://github.com/elljs/pnpm-mono","使用-maven-创建-java-monorepo#使用 Maven 创建 Java Monorepo":"初始化 Monorepo创建一个Monorepo项目。\nmkdir maven-mono\ncd maven-mono\n# 在根目录下创建 pom.xml\ntouch pom.xml\n# 在 api 目录中创建 pom.xml\nmkdir api && touch api/pom.xml\n# 在 packagea 目录中创建 pom.xml\nmkdir packagea && touch packagea/pom.xml\n# 在 packageb 目录中创建 pom.xml\nmkdir packageb && touch packageb/pom.xml\n根目录中的 pom.xml 文件内容如下：\n<project>\n   <!-- 指定 Maven POM 模型的版本 -->\n   <modelVersion>4.0.0</modelVersion>\n   \n   <!-- 项目的基本信息 -->\n   <groupId>com.ell</groupId> <!-- 项目的组 ID，通常用于唯一标识项目或组织 -->\n   <artifactId>maven-monorepo</artifactId> <!-- 项目的 artifact ID，用于在组内部唯一标识项目 -->\n   <version>1.0.0-SNAPSHOT</version> <!-- 项目的版本号，SNAPSHOT 表示这是一个快照版本，可能还在开发中 -->\n   <packaging>pom</packaging> <!-- 打包类型，这里为 POM，表示这是一个父 POM，用于管理子模块 -->\n   \n   <!-- 列出此 POM 文件管理的子模块 -->\n   <modules>\n      <module>packagea</module> <!-- 子模块 packagea 的目录名 -->\n      <module>packageb</module> <!-- 子模块 packageb 的目录名 -->\n      <module>api</module> <!-- 子模块 api 的目录名 -->\n   </modules>\n   \n   <!-- 依赖管理部分，用于定义项目中使用的依赖项的版本，以便在子模块中引用而不需要重复版本号 -->\n   <dependencyManagement>\n      <dependencies>\n            <dependency>\n               <groupId>com.ell</groupId> <!-- 依赖项的组 ID -->\n               <artifactId>monorepo</artifactId> <!-- 依赖项的 artifact ID -->\n               <version>1.0.0</version> <!-- 依赖项的版本号，注意这里应该是一个已发布的稳定版本，而不是 SNAPSHOT，除非你有特殊需求 -->\n            </dependency>\n      </dependencies>\n   </dependencyManagement>\n</project>\npackagea 中的文件，内容如下:\npackage com.ell.packagea;\npublic class PackageA {\n   public void methodA() {\n      System.out.println(\"Method A from Package A\");\n   }\n}\n<project>\n   <!-- 指定 Maven POM 模型的版本 -->\n   <modelVersion>4.0.0</modelVersion>\n   \n   <!-- 指定当前项目的父 POM -->\n   <parent>\n      <!-- 父项目的组 ID -->\n      <groupId>com.ell</groupId>\n      <!-- 父项目的 artifact ID -->\n      <artifactId>maven-monorepo</artifactId>\n      <!-- 父项目的版本号 -->\n      <version>1.0.0-SNAPSHOT</version>\n      <!-- 父 POM 文件的相对路径，这里表示父 POM 位于上一级目录中 -->\n      <relativePath>../pom.xml</relativePath>\n   </parent>\n   \n   <!-- 当前项目的 artifact ID，这里表示该项目是父项目 maven-monorepo 的一个子模块 -->\n   <artifactId>packagea</artifactId>\n</project>\npackageb 中的文件，内容如下:\npackage com.ell.packageb;\npublic class PackageB {\n   public void methodB() {\n      System.out.println(\"Method B from Package B\");\n   }\n}\n<project>\n   <!-- 指定 Maven POM 模型的版本 -->\n   <modelVersion>4.0.0</modelVersion>\n   \n   <!-- 指定当前项目的父 POM -->\n   <parent>\n      <!-- 父项目的组 ID -->\n      <groupId>com.ell</groupId>\n      <!-- 父项目的 artifact ID -->\n      <artifactId>maven-monorepo</artifactId>\n      <!-- 父项目的版本号 -->\n      <version>1.0.0-SNAPSHOT</version>\n      <!-- 父 POM 文件的相对路径，这里表示父 POM 位于上一级目录中 -->\n      <relativePath>../pom.xml</relativePath>\n   </parent>\n   \n   <!-- 当前项目的 artifact ID，这里表示该项目是父项目 maven-monorepo 的一个子模块 -->\n   <artifactId>packagea</artifactId>\n</project>\napi 中的文件，内容如下:\npackage com.ell.api;\nimport com.ell.packagea.PackageA;\nimport com.ell.packageb.PackageB;\npublic class Api {\n   public static void main(String[] args) {\n      PackageA packageA = new PackageA();\n      packageA.methodA();\n      PackageB packageB = new PackageB();\n      packageB.methodB();\n   }\n}\n<project>\n   <!-- 指定 Maven POM 模型的版本 -->\n   <modelVersion>4.0.0</modelVersion>\n   \n   <!-- 指定当前项目的父 POM -->\n   <parent>\n      <!-- 父项目的组 ID -->\n      <groupId>com.ell</groupId>\n      <!-- 父项目的 artifact ID -->\n      <artifactId>maven-monorepo</artifactId>\n      <!-- 父项目的版本号 -->\n      <version>1.0.0-SNAPSHOT</version>\n      <!-- 父 POM 文件的相对路径，这里表示父 POM 位于上一级目录中 -->\n      <relativePath>../pom.xml</relativePath>\n   </parent>\n   \n   <!-- 当前项目的 artifact ID，这里表示该项目是父项目 maven-monorepo 的一个子模块 -->\n   <artifactId>api</artifactId>\n   \n   <!-- 项目依赖项列表，这里列出了当前项目需要的其他 Maven 项目或库 -->\n   <dependencies>\n      <!-- packagea 的依赖项，表示当前项目依赖于 com.ell 组的 packagea 项目 -->\n      <dependency>\n            <groupId>com.ell</groupId> <!-- 依赖项的组 ID -->\n            <artifactId>packagea</artifactId> <!-- 依赖项的 artifact ID -->\n            <version>1.0.0-SNAPSHOT</version> <!-- 依赖项的版本号，这里同样使用的是快照版本 -->\n      </dependency>\n      \n      <!-- packageb 的依赖项，表示当前项目还依赖于 com.ell 组的 packageb 项目 -->\n      <dependency>\n            <groupId>com.ell</groupId> <!-- 依赖项的组 ID -->\n            <artifactId>packageb</artifactId> <!-- 依赖项的 artifact ID -->\n            <version>1.0.0-SNAPSHOT</version> <!-- 依赖项的版本号，同样使用的是快照版本 -->\n      </dependency>\n   </dependencies>\n</project>\n完整的目录结构如下：\n构建执行 mvn clean install 命令，这将编译和打包所有项目，并生成相应的 jar 包和 pom 文件。\nmvn\n这是 Maven 的命令行工具，用于执行 Maven 的各种命令和生命周期阶段。\nclean\nclean 是 Maven 的一个生命周期阶段，位于 validate 之后。它的主要目的是清理项目之前构建生成的文件，确保从干净的状态开始新的构建。这通常包括删除 target 目录（或你配置的任何其他构建输出目录），该目录通常包含编译后的类文件、打包的 JAR 文件、测试报告等。执行 clean 阶段时，Maven 会调用与清理相关的插件目标。例如，maven-clean-plugin 的 clean 目标负责删除构建输出目录。\ninstall\ninstall 是 Maven 的另一个生命周期阶段，位于 package 之后，deploy 之前。它的主要目的是将项目构建并打包（如 JAR、WAR 等），然后将这个包安装到本地 Maven 仓库中。这样，其他项目就可以作为依赖项来引用它，而无需将其包含在源代码仓库中。执行 install 阶段时，Maven 会首先执行 compile、test（如果启用了测试）、package 等阶段，以确保项目已经过编译、测试并打包。然后，它会调用与安装相关的插件目标。例如，maven-install-plugin 的 install 目标负责将构建的输出安装到本地 Maven 仓库中。\nmvn clean install\n当你运行 mvn clean install 命令时，Maven 会首先执行 clean 阶段来清理之前的构建输出，然后执行 install 阶段来构建项目并将其安装到本地 Maven 仓库中。这个命令非常适合于在开发过程中确保你的项目是从干净的状态开始构建的，并且构建的输出被正确地安装到了本地仓库中，以便其他项目可以引用它。\n使用插件在 api/pom.xml 中添加一个 maven 插件，用于执行 java 项目的启动命令。\n<project>\n   <modelVersion>4.0.0</modelVersion>\n   <parent>\n      <groupId>com.ell</groupId>\n      <artifactId>maven-monorepo</artifactId>\n      <version>1.0.0-SNAPSHOT</version>\n      <relativePath>../pom.xml</relativePath>\n   </parent>\n   <artifactId>api</artifactId>\n   <dependencies>\n      <dependency>\n            <groupId>com.ell</groupId>\n            <artifactId>packagea</artifactId>\n            <version>1.0.0-SNAPSHOT</version>\n      </dependency>\n      <dependency>\n            <groupId>com.ell</groupId>\n            <artifactId>packageb</artifactId>\n            <version>1.0.0-SNAPSHOT</version>\n      </dependency>\n   </dependencies>\n   <build>\n      <pluginManagement>\n            <plugins>          \n               <plugin>\n                  <groupId>org.codehaus.mojo</groupId>\n                  <artifactId>exec-maven-plugin</artifactId>\n                  <version>3.0.0</version>\n                  <configuration>\n                        <mainClass>com.ell.api.Api</mainClass>\n                  </configuration>\n               </plugin>      \n            </plugins>\n      </pluginManagement>\n   </build>\n</project>\n运行项目\nmvn -f api/pom.xml exec:java\n-f api/pom.xml\n-f 或 --file 选项用于指定要使用的 POM 文件的位置。在这个例子中，它指向 api/pom.xml，这意味着 Maven 将会使用位于 api 目录下的 pom.xml 文件作为项目的对象模型（POM）。这通常用于多模块项目中的子模块，或者当你想要从一个不是当前工作目录的位置运行 Maven 时。\nexec:java\n这部分指定了要执行的 Maven 插件目标和/或配置。在这个例子中，它使用 exec:java 插件目标，这意味着 Maven 将会执行 exec:java 插件，并且使用配置中指定的 mainClass 参数来启动 Java 应用程序。\n(base) \u001b[0;32m ➜ \u001b[0m \u001b[38;5;31mmaven-mono\u001b[0m mvn -f api/pom.xml exec:java\n[\u001b[38;5;31mINFO\u001b[0m] Scanning for projects...\n[\u001b[38;5;31mINFO\u001b[0m]\n[\u001b[38;5;31mINFO\u001b[0m] ----------------------------< \u001b[38;5;31mcom.ell:api\u001b[0m >-----------------------------\n[\u001b[38;5;31mINFO\u001b[0m] Building api 1.0.0-SNAPSHOT\n[\u001b[38;5;31mINFO\u001b[0m]   from pom.xml\n[\u001b[38;5;31mINFO\u001b[0m] --------------------------------[ jar ]---------------------------------\n[\u001b[38;5;31mINFO\u001b[0m]\n[\u001b[38;5;31mINFO\u001b[0m] --- \u001b[0;32mexec:3.0.0:java\u001b[0m (default-cli) @ \u001b[38;5;31mapi\u001b[0m ---\nMethod A from Package A\nMethod B from Package B\n[\u001b[38;5;31mINFO\u001b[0m] ------------------------------------------------------------------------\n[\u001b[38;5;31mINFO\u001b[0m] \u001b[0;32mBUILD SUCCESS\u001b[0m\n[\u001b[38;5;31mINFO\u001b[0m] ------------------------------------------------------------------------\n[\u001b[38;5;31mINFO\u001b[0m] Total time:  0.311 s\n[\u001b[38;5;31mINFO\u001b[0m] Finished at: 2024-11-29T00:24:57+08:00\n[\u001b[38;5;31mINFO\u001b[0m] ------------------------------------------------------------------------\n源码地址：https://github.com/elljs/maven-mono"}}}